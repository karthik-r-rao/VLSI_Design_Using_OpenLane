# RV32I Base Instruction Set

### More details about the instructions can be found in the [RISC-V Instruction Set Manual](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf).
<!DOCTYPE html>
<html>
<body>
<table>
    <tr>
        <th>Instruction</th>
        <th>Opcode [6:0]</th>
        <th>Funct3 [14:12]</th>
        <th>Funct7 [31:25]</th>
        <th>Description</th>
    </tr>
    <tr>
        <td>LUI</td>
        <td>0110111</td>
        <td></td>
        <td></td>
        <td>Load Upper Immediate places the immediate value in the top 20 bits of rd, filling the lowest 12 bits with zeros.</td>
    </tr>
    <tr>
        <td>AUIPC</td>
        <td>0010111</td>
        <td></td>
        <td></td>
        <td>Add Upper Immediate to PC forms a 32 bit offset from the 20-bit U-Immediate, filling in the lowest 12 bits with zeros, adds this offset to the PC, then places result in rd.</td>
    </tr>
    <tr>
        <td>JAL</td>
        <td>1101111</td>
        <td></td>
        <td></td>
        <td>Jump and Link takes the 20 bit offset, sign-extends it, and adds it to the PC to form the jump target address. JAL stores the address of the instruction following the jump (PC+4) into rd. Range- 1MiB</td>
    </tr>
    <tr>
        <td>JALR</td>
        <td>1100111</td>
        <td>000</td>
        <td></td>
        <td>Jump and Link Register computes target address by adding the 12-bit signed immediate to register rs1, then sets the LSB of the result to 0. The address of the instruction following the jump (PC+4) is written into rd. </td>
    </tr>
    <tr>
        <td>BEQ</td>
        <td>1100011</td>
        <td>000</td>
        <td></td>
        <td rowspan="6">Branch adds the 12 bit immediate value to the current PC to get the target address. BEQ and BNE take the branch if registers rs1 and rs2 are equal or unequal respectively. BLT and BLTU take the branch if rs1 is less than rs2, using signed and unsigned comparison respectively. BGE and BGEU take the branch if rs1 is greater than or equal to rs2, using signed and unsigned comparison respectively. Range- 4KiB</td>
    </tr>
    <tr>
        <td>BNE</td>
        <td>1100011</td>
        <td>001</td>
        <td></td>
    </tr>
    <tr>
        <td>BLT</td>
        <td>1100011</td>
        <td>100</td>
        <td></td>
    </tr>
    <tr>
        <td>BGE</td>
        <td>1100011</td>
        <td>101</td>
        <td></td>
    </tr>
    <tr>
        <td>BLTU</td>
        <td>1100011</td>
        <td>110</td>
        <td></td>
    </tr>
    <tr>
        <td>BGEU</td>
        <td>1100011</td>
        <td>111</td>
        <td></td>
    </tr>
    <tr>
        <td>LB</td>
        <td>0000011</td>
        <td>000</td>
        <td></td>
        <td rowspan="5">The LW instruction loads a 32-bit value from memory into rd. LH loads a 16-bit value from memory, then sign-extends to 32-bits before storing in rd. LHU loads a 16-bit value from memory but then zero extends to 32-bits before storing in rd. LB and LBU are defined analogously for 8-bit values. The effective byte address is obtained by adding register rs1 to the sign-extended 12-bit offset.</td>
    </tr>
    <tr>
        <td>LH</td>
        <td>0000011</td>
        <td>001</td>
        <td></td>
    </tr>
    <tr>
        <td>LW</td>
        <td>0000011</td>
        <td>010</td>
        <td></td>
    </tr>
    <tr>
        <td>LBU</td>
        <td>0000011</td>
        <td>100</td>
        <td></td>
    </tr>
    <tr>
        <td>LHU</td>
        <td>0000011</td>
        <td>101</td>
        <td></td>
    </tr>
    <tr>
        <td>SB</td>
        <td>0100011</td>
        <td>000</td>
        <td></td>
        <td rowspan="3">The SW, SH, and SB instructions store 32-bit, 16-bit, and 8-bit values from the low bits of register rs2 to memory. The effective byte address is obtained by adding register rs1 to the sign-extended 12-bit offset.</td>
    </tr>
    <tr>
        <td>SH</td>
        <td>0100011</td>
        <td>001</td>
        <td></td>
    </tr>
    <tr>
        <td>SW</td>
        <td>0100011</td>
        <td>010</td>
        <td></td>
    </tr>
    <tr>
        <td>ADDI</td>
        <td>0010011</td>
        <td>000</td>
        <td></td>
        <td rowspan="6">The 12-bit immediate value is sign-extended and added to rs1. Result is stored in rd. The other ops are similar. SLTI (set less than immediate) places the value 1 in register rd if register rs1 is less than the sign- extended immediate when both are treated as signed numbers, else 0 is written to rd. SLTIU is similar but compares the values as unsigned numbers (i.e., the immediate is first sign-extended to 32 bits then treated as an unsigned number). </td>
    </tr>
    <tr>
        <td>SLTI</td>
        <td>0010011</td>
        <td>010</td>
        <td></td>
    </tr>
    <tr>
        <td>SLTIU</td>
        <td>0010011</td>
        <td>011</td>
        <td></td>
    </tr>
    <tr>
        <td>XORI</td>
        <td>0010011</td>
        <td>100</td>
        <td></td>
    </tr>
    <tr>
        <td>ORI</td>
        <td>0010011</td>
        <td>110</td>
        <td></td>
    </tr>
    <tr>
        <td>ANDI</td>
        <td>0010011</td>
        <td>111</td>
        <td></td>
    </tr>
    <tr>
        <td>SLLI</td>
        <td>0010011</td>
        <td>001</td>
        <td>0000000</td>
        <td rowspan="3">Shift ops have the operand in rs1, and the shift amount (shamt) is encoded with 5 bits in the instruction. </td>
    </tr>
    <tr>
        <td>SRLI</td>
        <td>0010011</td>
        <td>101</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>SRAI</td>
        <td>0010011</td>
        <td>101</td>
        <td>0100000</td>
    </tr>
    <tr>
        <td>ADD</td>
        <td>0110011</td>
        <td>000</td>
        <td>0000000</td>
        <td rowspan="10">SLL, SRL, and SRA perform logical left, logical right, and arithmetic right shifts on the value in
register rs1 by the shift amount held in the lower 5 bits of register rs2. The other ops are straightforward.</td>
    </tr>
    <tr>
        <td>SUB</td>
        <td>0110011</td>
        <td>000</td>
        <td>0100000</td>
    </tr>
    <tr>
        <td>SLL</td>
        <td>0110011</td>
        <td>001</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>SLT</td>
        <td>0110011</td>
        <td>010</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>SLTU</td>
        <td>0110011</td>
        <td>011</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>XOR</td>
        <td>0110011</td>
        <td>100</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>SRL</td>
        <td>0110011</td>
        <td>101</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>SRA</td>
        <td>0110011</td>
        <td>101</td>
        <td>0100000</td>
    </tr>
    <tr>
        <td>OR</td>
        <td>0110011</td>
        <td>110</td>
        <td>0000000</td>
    </tr>
    <tr>
        <td>AND</td>
        <td>0110011</td>
        <td>111</td>
        <td>0000000</td>
    </tr>
</table>
</body>
</html>
